#!/usr/bin/env bash

# ============================================================================================================
# Script to install minilibx on linux
#
# Linux install steps:
#   - step 0: Exec the script as sudo
#   - step 1: Check and install this script's dependancies (cmds:date, git, perl, sed, yes).
#   - step 2: Update and Upgrade the system (skippable step, but good practice before any installation).
#   - step 3: Check and install mlx's dependancies (LINUX_MLX_DEPS var. , check minilibx README to update list).
#   - step 4: Clone and Make minilibx (MLX_PATH var. can be change to modify path and mlx folder's name).
#   - step 5: Create a env_file, sourcing this file will add mlx's doc to man cmd (using MANPATH env-var).
#
# Two files are generated by this script:
#   - env_file --> contain the new MANPATH value (need to be manually sourced).
#   - <script_parent_dir>/<date><time>.log --> each exec. generates a log file that contains all cmds output.
#
# TODO-LIST: install.sh features
#  -[x] linux support.
#  -[ ] macOS support.
#
#                                                                                                 by alterGNU
# ============================================================================================================

# ============================================================================================================
# LINUX VARIABLES
# ============================================================================================================
# -[ dict of cmd:pck needed by this script ]------------------------------------------------------------------
declare -A LINUX_PRE_REQUIS_CMDS=( \
    ["date"]="coreutils" \
    ["git"]="git" \
    ["perl"]="perl" \
    ["sed"]="sed" \
    ["yes"]="coreutils" \
)
# -[ List of MLX's dependancies to installed ]----------------------------------------------------------------
LINUX_MLX_DEPS=(\
    "clang" \
    "gcc" \
    "libbsd-dev" \
    "libx11-dev" \
    "libxext-dev"\
    "make" \
    "xorg" \
)
# -[ URL to minilibx-linux's github repo ]--------------------------------------------------------------------
MLX_URL="https://github.com/42paris/minilibx-linux.git"
# -[ Minilibx folders path (and name) ]-----------------------------------------------------------------------
MLX_PATH=${PWD}"/mlx"
# -[ COLOR BALISE ]-------------------------------------------------------------------------------------------
E="\033[0m"
B="\033[1;36m"
R="\033[1;31m"
HG="\033[0;47m"
G="\033[0m\033[2;37m"
V="\033[2;32m"
UB="\033[4;36m"
M="\033[1;33m"
UG="\033[4;37m"
Y="\033[0;93m"
# -[ max line size ]------------------------------------------------------------------------------------------
LEN=80
# -[ separator symbole ]--------------------------------------------------------------------------------------
SEP="."
# -[ Script absolute path ]-----------------------------------------------------------------------------------
PARENT_DIR=$(cd $(dirname ${0}) && pwd)
# -[ tmp file created to be source ]--------------------------------------------------------------------------
env_file=${PARENT_DIR}/env_file
# -[ log file with commands details ]-------------------------------------------------------------------------
log_file="${PARENT_DIR}/$(date +%Y_%m_%d_%Hh%Mm%Ss)_mlx_install.log"

# ============================================================================================================
# UTILITY FUNCTIONS
# ============================================================================================================
# -[ GET_LEN ]------------------------------------------------------------------------------------------------
# return real len, handle emoticon that need space after to avoid overlapping display in terminal
get_len()
{
    local str=${1}
    local LIST_EMOTIC_DOUBLE_OCT=( "☑️" "⚙️" "⚠️" "✖️" )
    local clean_str=$(echo -en "${str}" | sed 's/\x1b\[[0-9;]*m//g')
    for emo in "${LIST_EMOTIC_DOUBLE_OCT[@]}"; do clean_str="${clean_str//${emo} /${emo}}"; done
    local nb_emo=$(echo -n "${clean_str}" | perl -CSD -lne 'print scalar(() = /\p{Extended_Pictographic}/g)')
    clean_str=$(echo -n "${clean_str}" | perl -CSD -pe 's/\p{Extended_Pictographic}//g')
    local count=$(echo -n "${clean_str}" | perl -CSD -lne 'print scalar(() = /\X/g)')
    echo $(( count + nb_emo + nb_emo ))
}
# -[ PRINT N TIMES ]------------------------------------------------------------------------------------------
# print $arg1 $arg2 times
pnt() { for i in $(seq 0 $((${2})));do echo -en ${1};done ; }
# -[ print in log_file ]--------------------------------------------------------------------------------------
print_in_log_file(){ echo -e "\n${@}" >> ${log_file} ; }
# -[ print title one(step name) ]-----------------------------------------------------------------------------
title_1(){ echo -en "\n${HG}${B}${@}${E}\n" ; }
# -[ print title two(step name) ]-----------------------------------------------------------------------------
title_2(){ echo -en "${UB}${@}${E}" ; }
# -[ Check if a command exist ]-------------------------------------------------------------------------------
cmd_exist(){ command -v "${1}" > /dev/null 2>&1 ; }
# -[ Check if command:${1} is installed, else install the corresponding package:${2} ]------------------------
install_cmd()
{
    local cmd_name=${1}
    local pck_name=${1}
    [[ ${#} -eq 2 ]] && local pck_name=${2}
    local txt="- cmd ${V}${cmd_name}${E} in pck ${B}${pck_name}${E}:"
    local len=$(get_len "$txt")
    echo -en ${txt}
    if cmd_exist "${cmd_name}";then
        local suf="${G} (already installed)${E} ☑️ "
    else
        print_in_log_file sudo apt install ${pck_name}
        sudo apt install -y ${pck_name} 1>> ${log_file}\
            && local suf="${V} (successfully installed)${E} ✅" \
            || local suf="${R} Failed to install${E} ❌"
        print_in_log_file "\n"
    fi
    local suf_len=$(get_len "${suf}")
    pnt ${SEP} $((LEN - $len - $suf_len))
    echo -e "${suf}"
}
# -[ Check if a package was installed ]-----------------------------------------------------------------------
pck_installed(){ dpkg-query -W -f='${Status}' "${1}" 2>/dev/null | grep -q "install ok installed" ; }
# -[ Check if a package is installed, else install it ]-------------------------------------------------------
install_pck()
{
    local txt="- package ${B}${1}${E}:"
    local len=$(get_len "${txt}")
    echo -en ${txt}
    if pck_installed "${1}";then
        local suf="${G} (already installed)${E} ☑️ "
    else
        print_in_log_file sudo apt install ${pck_name}
        sudo apt install -y ${1} 1>> ${log_file}\
            && local suf="${V} (successfully installed)${E} ✅" \
            || local suf="${R} Failed to install${E} ❌ "
        print_in_log_file "\n"
    fi
    local suf_len=$(get_len "${suf}")
    pnt ${SEP} $((LEN - $len - $suf_len))
    echo -e "${suf}"
}

# ============================================================================================================
# MAIN
# ============================================================================================================
# =[ A.1 | log in as sudo ]===================================================================================
OS=$(uname -s)
if [ "${OS}" == "Linux" ];then
    [[ "$EUID" -ne 0 ]] && title_1 "0  | Exec the script with sudo:" && exec sudo "$0" "$@"
    title_1 "1  | Linux OS Detected:"

    # =[ A.2 | Check 'yes' is installed ]=====================================================================
    title_1 "2  | Check script commandes dependancies:"
    for cmd in "${!LINUX_PRE_REQUIS_CMDS[@]}";do install_cmd ${cmd} ${LINUX_PRE_REQUIS_CMDS[${cmd}]};done

    # =[ A.3 | Update system ]================================================================================
    title_1 "3  | Update System:"
    read -p "Do you want to run apt update, upgrade, and autoremove? (y/yes or n/no): " update_choice
    if [[ "$update_choice" =~ ^[Yy]([Ee][Ss])?$ ]]; then
    	title_2 "2.1| Update:" && pnt "${B}${SEP}${E}" $((LEN - 12)) && echo
    	sudo apt update && pnt ${B}"${SEP}${E}" "$((LEN - 2))" && echo "✅"
    	title_2 "2.2| Upgrade:" && pnt "${B}${SEP}${E}" $((LEN - 13)) && echo
    	sudo apt upgrade && pnt ${B}"${SEP}${E}" "$((LEN - 2))" && echo "✅"
    	title_2 "2.3| Autoremove:" && pnt "${B}${SEP}${E}" $((LEN - 16)) && echo
    	sudo apt autoremove && pnt "${B}${SEP}${E}" "$((LEN - 2))" && echo "✅"
    else
    	echo -e ${Y}"⏭️  Skipping Update System Step"${E}
    fi

    # =[ A.4 | Install MLX's dependancies packages: ]=========================================================
    title_1 "4  | Check Minilibx packages dependancies:"
    for pkg in ${LINUX_LINUX_MLX_DEPS[@]};do install_pck ${pkg};done

elif [ "${OS}" == "Darwin" ];then
    title_1 "1  | macOS Detected:"
    #echo -e "${R}⚠️  macOS installation is not yet supported by this script.${E}"
    # =[ B.2 | Check 'cmds' installed ]=======================================================================
    title_1 "2  | Check script commandes dependancies:"
    title_2 "2.1| Check ${V}curl${BU} cmd is installed:\n"
    if cmd_exist "curl";then
        echo -en "- cmd ${V}curl${E} "
        pnt ${SEP} $((LEN - 31))
        echo -en "(already installed) ☑️\n"
    else
        title_2 "${R}⚠️  curl is not installed. Please install it and re-run this script.${E}"
        exit 1
    fi
    title_2 "2.2| Check ${V}brew${BU} cmd is installed:\n"
    if cmd_exist "brew";then
        echo -en "- cmd ${V}brew${E} "
        pnt ${SEP} $((LEN - 31))
        echo -en "(already installed) ☑️\n"
    else
        title_2 "${R}⚠️  Homebrew is not installed. Please install it using the following command:${E}"
        echo "/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
        exit 1
    fi
    # =[ B.3 | Install xquartz ]=============================================================================
    title_2 "2.3| Install xquartz:\n"
    if brew list xquartz &> /dev/null 2>&1; then
        echo -en "- ${V}XQuartz${E} already installed by brew cmd"
        pnt ${SEP} $((LEN - 40))
        echo -en " ☑️\n"
    else
        # XQuartz not installed via brew
        echo -en "- ${V}XQuartz${E} not installed ${R}reboot needed after installation"${E}
        brew install --cask xquartz
        echo -en "- ${V}XQuartz${E} successfully installed ${R}reboot needed"${E}
        read -p "Do you want to reboot now? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            sudo reboot
        fi
    fi
else
    title_1 "1  | Unknown OS Detected"
    exit 1
fi
# =[ 5 | Git clone and Make minilibx if mlx folder not at $PWD ]==========================================
title_1 "5  | Clone and Make minilibx:"
title_2 "5.1| Git clone:"
if [ ! -d ${MLX_PATH} ];then
    pnt ${SEP} $((LEN - 18))
    print_in_log_file git clone ${MLX_URL} ${MLX_PATH}
    git clone ${MLX_URL} ${MLX_PATH} >> ${log_file} 2>&1 && echo -e " ✅"${E} || echo -e " ❌"${E}
else
    pnt ${SEP} $((LEN - 34))
    echo -e "${G}(already cloned) ☑️"${E}
fi
title_2 "5.2| Make mlx:"
if [ -d ${MLX_PATH} ];then
    print_in_log_file "cd ./mlx && ./configure:"
    if [[ ! -f "${MLX_PATH}/libmlx.a" ]];then
        pnt ${SEP} $((LEN - 17))
        { cd ${MLX_PATH} && ./configure >> ${log_file} 2>&1 ; } && echo -e " ✅"${E} || echo -e " ❌"${E}
    else
        pnt ${SEP} $((LEN - 31))
        echo -e "${G}(already made) ☑️"${E}
    fi
else
    pnt ${SEP} $((LEN - 35))
    echo -e "${R}(git clone failed) ❌${E}"
fi
title_2 "5.3| Change mlx folder owner from root to user:"
if [ -d ${MLX_PATH} ];then
	pnt ${SEP} $((LEN - 50))
	chown -R ${SUDO_USER}:${SUDO_USER} ${MLX_PATH} && echo -e " ✅"${E} || echo -e " ❌"${E}
else
	pnt ${SEP} $((LEN - 72))
	echo -e "${R}(mlx folder not found) ❌"${E}
fi
echo -e "\n${M}for more details, check log file:\n - ${Y}${log_file}${E}"

# =[ 6 | Add mlx's doc to man command ]===================================================================
title_1 "6  | Add mlx's doc to man command:"
title_2 "\n6.1| Temporary :\n"
echo "export MANPATH=\"${MLX_PATH}/man:\$MANPATH\"" > ${env_file}
echo -e "- Exec:${R} \`${UG}source ${env_file}${E}${R}\`${G} (Add mlx/man/ folder to MANPATH env-var.)${E}"
echo -e "- Test:${R} \`${UG}man mlx${E}${R}\`${G} (should display mlx man page)${E}"
title_2 "\n6.2| Permanently :\n"
echo -e "- Add this line: '${M}export MANPATH=\"${MLX_PATH}/man:\$MANPATH\"${E}'\n- In any startup dotfile: ${G}(e.g. .zshrc, .bashrc, .profile)${E}\n- Then manually source this dotfile once, or just restart the session."
echo -e "${G}(Note that now ${MLX_PATH}/man must not be removed ^^')${E}"