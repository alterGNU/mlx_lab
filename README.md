# mlx_lab: Minilibx laboratory

## A | SCRIPTS

### A.1 | `install_mlx.sh`: Install minilibx on linux.

```bash
git clone https://github.com/alterGNU/mlx_lab.git && cd mlx_lab && ./install_mlx.sh
```
- Main steps:
  - step 0: Exec the script as sudo
  - step 1: Check and install this script's dependancies (cmds:date, git, perl, sed, yes).
  - step 2: Update and Upgrade the system (skippable step, but good practice before any installation).
  - step 3: Check and install mlx's dependancies (MLX_DEPS var. , check minilibx README to update list).
  - step 4: Clone and Make minilibx (MLX_PATH var. can be change to modify path and mlx folder's name).
  - step 5: Create a env_file, sourcing this file will add mlx's doc to man cmd (using MANPATH env-var).

- Two files are generated by this script:
  - `<script_parent_dir>/env_file` --> contain the new MANPATH value (need to be manually sourced to add mlx's doc to `man`).
  - `<script_parent_dir>/<date><time>.log` --> each exec. generates a log file that contains all cmds output details.

### A.2 | `clean.sh`: clean mlx_lab folder.
```bash
cd mlx_lab && ./clean.sh
```
- Main steps:
  - step 1: Remove scripts generated files (`env_file` and `*.log` files)
  - step 2: Remove sub-folders in list `SUB_FOLDERS_TO_DEL=( "mlx" )`

## B | Add mlx to project's Makefile:
- B.1 | Rules to git clone mlx and make minilibx.
    ```bash
    MLX_DIR =	./mlx
    MLX_A   =	$(MLX_DIR)/libmlx.a
    MLX_URL =	https://github.com/42Paris/minilibx-linux.git
    $(NAME): $(MLX_A) ...
      ...
    $(MLX_A):
        if [ ! -d ${MLX_DIR} ];then git clone $(MLX_URL) $(MLX_DIR); fi
        make -C $(MLX_DIR)
    ```
- B.2 | Update compilation rules:
  - B.2.1 | Add mlx flags:`-lX11 -lXext -lm`
  - B.2.2 | Add static lib:`<path_to>/libmlx.a`
  - B.2.3 | Add header's folder:`-I<path_to_folder_that_contains_mlx.h>`
  ```bash
  MLX_DIR = ./mlx
  MLX_A   = $(MLX_DIR)/libmlx.a
  F_ADD   = -lX11 -lXext -lm
  FLAGS   = -Wall -Wextra -Werror -I. -I$(MLX_DIR)
  $(NAME): $(MLX_A) $(OBJ)
	  cc $(FLAGS) $(OBJ) $(MLX_A) -o $(NAME) $(F_ADD)
  %.o: %.c
	  cc $(FLAGS) -c $< -o
  ```

> [!WARNING]  
> Modern linker `ld >= 2.40`, order is strict: `$(OBJ) < $(MLX_A) < $(F_ADD)`

- B.3 | Update clean and fclean rules:
  ```bash
  clean:
    ...
    make -C $(MLX_DIR) clean
  fclean:
    ...
	  if [ -d $(MLX_DIR) ];then rm -rf $(MLX_DIR);fi
  ```

## C | mlx's basic init and free functions

### C.1 | Starting point of any MLX program: `void *mlx_init()`
- This function create a **connection** between your program and your computer's **display server**.
- Return value:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*mlx_ptr)...PANIC`
  - ON SUCCESS return a `mlx_ptr` --> used by all other MLX functions(~ACCESS ID OF DISPLAY SERVER)
- Freeing `mlx_ptr`--> `mlx_destroy_display()` + `free()` + set at NULL
  ```c
  void *mlx_ptr = mlx_init();
  ...
  mlx_destroy_display(mlx_ptr);
  free(mlx_ptr);
  mlx_ptr = NULL;
  ```

### C.2 | Manage windows: `void *mlx_new_window(void *mlx_ptr, int x, int y, char *title)`
- This function asks the **display server** to create a new window.
- Return value:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*win_ptr)...PANIC`
  - ON SUCCESS return a `win_ptr` --> used by other windows functions(~WINDOW ID)
- Freeing `win_ptr`--> `mlx_destroy_window()` + set at NULL
  ```c
  void *win_ptr = mlx_new_window(mlx_ptr, 400, 800, "titre");
  ...
  mlx_destroy_window(mlx_ptr, win_ptr);
  win_ptr = NULL;
  ```
- Examples: `src/c_basic_init_free_window.c`
  - basic use of `mlx_init()`,`mlx_destroy_display()`, `mlx_new_windows()`, `mlx_destroy_window()`
  ```c
  cc -Wall -Wextra -Werror -Imlx src/c_basic_init_free_window.c mlx/libmlx.a -o t1_win -lXext -lX11 
  ```
  - create and destroy display and window without displaying anything (too quick), use just to check leaks with valgrind
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t1_win
  ```

> [!CAUTION]
> mlx_new_window triggers the Valgrind warning, add `--undef-value-errors=no` flags to delete false-negative warnings.

### C.3 | Manage images: `void *mlx_new_image(void *mlx_ptr, int x, int y)`
- This function creates a new image in memory. 
- Return value:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*img_ptr)...PANIC`
  - ON SUCCESS return a `img_ptr` --> used by other manipulating images functions(~IMAGES ID)
- Freeing `img_ptr`--> `mlx_destroy_image()` + set at NULL
  ```c
  void *img_ptr = mlx_new_image(mlx_ptr, 1920, 1080);
  ...
  mlx_destroy_image(mlx_ptr, img_ptr);
  img_ptr = NULL;
  ```
- Examples: `src/c_basic_init_free_image.c`-> create and destroy display and image (do not display anything)
  - basic use of `mlx_init()`,`mlx_destroy_display()`, `mlx_new_images()`, `mlx_destroy_image()`
  ```c
  cc -Wall -Wextra -Werror -Imlx src/c_basic_init_free_image.c mlx/libmlx.a -o t1_img -lXext -lX11 
  ```
  - create and destroy display and image without displaying anything (too quick), use just to check leaks with valgrind
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t1_img
  ```

## D | Display image `mlx_loop()`
In previous code example, our newly create window or image are not displayed on screen
_(Actually, they're displayed, but too quickly to being seen and then are destroyed)._
To fix this, a **'naive approch'** would have been to use a `while (true){...}` loop between init. and destruction.
A better way is to use the Minilibx provided `int mlx_loop(void *mlx_ptr)` function that handle events while looping infinitely.
_(This way, we can associate user-defined functions with events (exit loop when `[ESC]` key is pressed...)_

> [!NOTE]
> loop stop if `xvar->window_count < 1`:no window left(destroyed) or `xvar->end_loop > 0`:fun.`mlx_loop_end(mlx_ptr)`called

### Example: `src/d_display_window.c`-> display window
  - Add `mlx_loop` to previous code:
  ```c
  cc -Wall -Wextra -Werror -Imlx src/d_display_window.c mlx/libmlx.a -o t2_win -lXext -lX11 
  ```
  - create and destroy display and image without displaying anything (too quick), use just to check leaks with valgrind
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t2_win
  ```

> [!WARNING]
> Without event, loop can only be stopped with `[CTRL]+[C]` --> leaks!!!
