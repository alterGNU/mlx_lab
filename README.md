# mlx_lab: Minilibx laboratory

## A | SCRIPTS

### A.1 | `install_mlx.sh`: Install minilibx on linux.

```bash
git clone https://github.com/alterGNU/mlx_lab.git && cd mlx_lab && ./install_mlx.sh
```
- Main steps:
  - step 0: Exec the script as sudo
  - step 1: Check and install this script's dependancies (cmds:date, git, perl, sed, yes).
  - step 2: Update and Upgrade the system (skippable step, but good practice before any installation).
  - step 3: Check and install mlx's dependancies (MLX_DEPS var. , check minilibx README to update list).
  - step 4: Clone and Make minilibx (MLX_PATH var. can be change to modify path and mlx folder's name).
  - step 5: Create a env_file, sourcing this file will add mlx's doc to man cmd (using MANPATH env-var).

- Two files are generated by this script:
  - `<script_parent_dir>/env_file` --> contain the new MANPATH value (need to be manually sourced to add mlx's doc to `man`).
  - `<script_parent_dir>/<date><time>.log` --> each exec. generates a log file that contains all cmds output details.

### A.2 | `clean.sh`: clean mlx_lab folder.
```bash
cd mlx_lab && ./clean.sh
```
- Main steps:
  - step 1: Remove scripts generated files (`env_file` and `*.log` files)
  - step 2: Remove sub-folders in list `SUB_FOLDERS_TO_DEL=( "mlx" )`
  - step 3: Remove binary tests files (pattern:`t[0-9]_*`)

## B | Add mlx to project's Makefile:
- B.1 | Rules to git clone mlx and make minilibx.
    ```bash
    MLX_DIR =	./mlx
    MLX_A   =	$(MLX_DIR)/libmlx.a
    MLX_URL =	https://github.com/42Paris/minilibx-linux.git
    $(NAME): $(MLX_A) ...
      ...
    $(MLX_A):
        if [ ! -d ${MLX_DIR} ];then git clone $(MLX_URL) $(MLX_DIR); fi
        make -C $(MLX_DIR)
    ```
- B.2 | Update compilation rules:
  - B.2.1 | Add mlx flags:`-lX11 -lXext -lm`
  - B.2.2 | Add static lib:`<path_to>/libmlx.a`
  - B.2.3 | Add header's folder:`-I<path_to_folder_that_contains_mlx.h>`
  ```bash
  MLX_DIR = ./mlx
  MLX_A   = $(MLX_DIR)/libmlx.a
  F_ADD   = -lX11 -lXext -lm
  FLAGS   = -Wall -Wextra -Werror -I. -I$(MLX_DIR)
  $(NAME): $(MLX_A) $(OBJ)
	  cc $(FLAGS) $(OBJ) $(MLX_A) -o $(NAME) $(F_ADD)
  %.o: %.c
	  cc $(FLAGS) -c $< -o
  ```

> [!WARNING]  
> Modern linker `ld >= 2.40`, order is strict: `$(OBJ) < $(MLX_A) < $(F_ADD)`

- B.3 | Update clean and fclean rules:
  ```bash
  clean:
    ...
    make -C $(MLX_DIR) clean
  fclean:
    ...
	  if [ -d $(MLX_DIR) ];then rm -rf $(MLX_DIR);fi
  ```

## C | mlx's basic init and free functions

### C.1 | Starting point of any MLX program: `void *mlx_init()`

This function create a **connection** between your program and your computer's **display server**.

- **Return value**:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*mlx_ptr)...PANIC`
  - ON SUCCESS return a `mlx_ptr` --> used by all other MLX functions(~ACCESS ID OF DISPLAY SERVER)
- **Freeing**: 
  ```c
  void *mlx_ptr = mlx_init();
  ...
  mlx_destroy_display(mlx_ptr);
  free(mlx_ptr);
  mlx_ptr = NULL;
  ```

### C.2 | Manage windows: `void *mlx_new_window(void *mlx_ptr, int x, int y, char *title)`

This function asks the **display server** to create a new window.

- **Return value**:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*win_ptr)...PANIC`
  - ON SUCCESS return a `win_ptr` --> used by other windows functions(~WINDOW ID)
- **Freeing**:
  ```c
  void *win_ptr = mlx_new_window(mlx_ptr, 400, 800, "titre");
  ...
  mlx_destroy_window(mlx_ptr, win_ptr);
  win_ptr = NULL;
  ```
- **File**: [src/c_basic_init_free_window.c](https://github.com/alterGNU/mlx_lab/blob/main/src/c_basic_init_free_window.c)
  - **Objectifs**:
    - Manipulate display and window's basic fun. and check leaks with valgrind.
  - **Implementation**:
    - Call display's `mlx_init()` and `mlx_destroy_display()` fun.
    - Call window's `mlx_new_window()` and `mlx_destroy_window()` fun.
  - **Observations**:
    - `mlx_destroy_display()` **do not frees** `mlx_ptr` pointer var., setting at null needed too.
    - `mlx_destroy_window()` **frees** `win_ptr` pointer var., but setting at null needed.
    - Without a loop, nothing displayed on screen (too fast/quick).
- **Compilation**:
  ```c
  cc -Wall -Wextra -Werror -Imlx src/c_basic_init_free_window.c mlx/libmlx.a -o t1_win -lXext -lX11 
  ```
- **Valgrind**:
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t1_win
  ```

> [!CAUTION]
> mlx_new_window triggers the Valgrind warning, add `--undef-value-errors=no` flags to delete false-negative warnings.

### C.3 | Manage images: `void *mlx_new_image(void *mlx_ptr, int x, int y)`

This function creates a new image in memory. 

- **Return value**:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*img_ptr)...PANIC`
  - ON SUCCESS return a `img_ptr` --> used by other manipulating images functions(~IMAGES ID)
- **Freeing**:
  ```c
  void *img_ptr = mlx_new_image(mlx_ptr, 1920, 1080);
  ...
  mlx_destroy_image(mlx_ptr, img_ptr);
  img_ptr = NULL;
  ```
- **File**: [src/c_basic_init_free_image.c](https://github.com/alterGNU/mlx_lab/blob/main/src/c_basic_init_free_image.c)
  - **Objectifs**:
    - Manipulate image basic fun (creation and deletion)
  - **Implementation**:
    - Call window's `mlx_new_image()` and `mlx_destroy_image()` fun.
  - **Observations**:
    - `mlx_destroy_image()` **frees** `img_ptr` pointer var., but setting at null needed.
    - Without a loop, nothing displayed on screen (too fast/quick).
- **Compilation**:
  ```c
  cc -Wall -Wextra -Werror -Imlx src/c_basic_init_free_image.c mlx/libmlx.a -o t1_img -lXext -lX11 
  ```
- **Valgrind**:
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t1_img
  ```

## D | Display image `mlx_loop()`
In previous code example, our newly create window or image are not displayed on screen

_(Actually, they're displayed, but too quickly to being seen and then are destroyed)._

To fix this, a **'naive approch'** would have been to use a `while (true){...}` loop between init. and destruction.

A better way is to use the Minilibx provided `int mlx_loop(void *mlx_ptr)` function that handle events while looping infinitely.

_(This way, we can associate user-defined functions with events (exit loop when `[ESC]` key is pressed...)_

> [!NOTE]
> loop stop if `xvar->window_count < 1`:no window left(destroyed) or `xvar->end_loop > 0`:fun.`mlx_loop_end(mlx_ptr)`called

- **File**: [src/d_display_window.c](https://github.com/alterGNU/mlx_lab/blob/main/src/d_display_window.c)
  - **Objectifs**:
    - display the newly created window by adding a loop. _(destruction fun. wait the end of the loop)_
  - **Implementation**:
    - Calls `mlx_loop()` between window's creation and destruction funs.
  - **Observations**:
    - This time, a window is displayed, but wihtout hook on clean-exit fun., only `Ctrl+C` can kill the program, leading to leaks!
- **Compilation**:
  ```c
  cc -Wall -Wextra -Werror -Imlx src/d_display_window.c mlx/libmlx.a -o t2_win -lXext -lX11 
  ```
- **Valgrind**:
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t2_win
  ```

> [!WARNING]
> Without event, loop can only be stopped with `[CTRL]+[C]` --> leaks!!!

## E | Events
### E.1 | X11 Interface - Events
X-Window system is **bi-directionnal**:
  - The program sends orders to the screen to display pixels/images/...
  - The program can get information from keyboard/mouse associated to the screen by receving **events** from keyboard/mouse

Each event have an **int ID** and can be combined with a mask (int ID too) to whitelist or blacklist events.

- [Off. Docs: X11 events](https://tronche.com/gui/x/xlib/events/)

#### E.1.1 | events ID/KEY
```c
enum {
	ON_KEYDOWN = 2,
	ON_KEYUP = 3,
	ON_MOUSEDOWN = 4,
	ON_MOUSEUP = 5,
	ON_MOUSEMOVE = 6,
	ON_EXPOSE = 12,
	ON_DESTROY = 17
};
```
### E.2 | MinilibX API - Events
#### E.2.1 | Generic Access to X11-Event: `mlx_hook()`
- `int	mlx_hook(void *win_ptr, int x_event, int x_mask, int (*funct)(), void *param)`
  - `void *win_ptr`   : ptr to the window on which this assignment is specific
  - `int x_event`     : event id
  - `int x_mask`      : mask id
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

MLX therefore handle event with **mlx_hook aliases**:

#### E.2.2 | Alias to manage NO EVENT `mlx_loop_hook(win_ptr, fun, arg)`:
- When **NO EVENT** `int	mlx_loop_hook(t_xvar *xvar,int (*funct)(),void *param)` run:
  - `t_xvar *xvar`    : t_xvar struct (window id) on which this assignment is specific
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

> [!TIP]
> This mlx_hook alias function can be use to draw when no event detected.

#### E.2.3 | Alias to manage KEYUP pressing event: `mlx_key_hook(win_ptr, fun, arg)`
- When **a key is pressed** use alias: `int	mlx_key_hook(t_xvar *xvar,int (*funct)(),void *param)` run:
  - `t_xvar *xvar`    : t_xvar struct (window id) on which this assignment is specific
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

#### E.2.4 | Alias to manage MOUSE button pressing event: `mlx_mouse_hook(win_ptr, fun, arg)`
- When **the mouse is pressed** use alias: `int	mlx_mouse_hook(t_xvar *xvar,int (*funct)(),void *param)` run:
  - `t_xvar *xvar`    : t_xvar struct (window id) on which this assignment is specific
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

#### E.2.5 | Alias to manage EXPOSE event: `mlx_expose_hook(win_ptr, fun, arg)`
- When **a part of the window should be redraw**, use alias: `int	mlx_expose_hook(t_xvar *xvar,int (*funct)(),void *param)` run:
  - `t_xvar *xvar`    : t_xvar struct (window id) on which this assignment is specific
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

### E.3 | Examples with : Clean Exit Features
#### E.3.1 | Call `mlx_loop_end()` directly

>[!NOTE]
> This way is simplier, it will just stop the loop: just call cleaning functions in main after `mlx_loop()` calls.

##### E.3.1.a | On event Window's `[X]` Button.

**Clean Exit** when event: click on `[X]` windows --> `mlx_loop_end()` --> stop `mlx_loop()`

- **File**: [src/e_end_loop_destroy_window.c](https://github.com/alterGNU/mlx_lab/blob/main/src/e_end_loop_destroy_window.c)
  - **Objectifs**:
    - Displaying a window until the window's `[X]` Button clicked-on-->clean-exit!
  - **Implementation**:
    - Hook `[X]`Window's-Button with `mlx_hook()`-->calls `mlx_loop_end()` function.
  - **Observations**:
    - Cleaning and freeing functions must be called in main after `mlx_loop()` since `mlx_loop_end()` just stop the `mlx_loop()` fun.
- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/e_end_loop_destroy_window.c mlx/libmlx.a -o t3_end_loop_dest_win -lXext -lX11 
  ```
- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t3_end_loop_dest_win
  ```

##### E.3.2.b | On event Pressing Key `[ESC]` Down.

**Clean Exit** when event: press down `[ESC]` key --> `mlx_loop_end()` --> stop `mlx_loop()`

- **File**: [src/e_end_loop_esc_keydown.c](https://github.com/alterGNU/mlx_lab/blob/main/src/e_end_loop_esc_keydown.c)
  - **Objectifs**:
    - Handling clean exit by pressing down `[ESC]` key: unsing `mlx_loop_end()`
  - **Implementation**:
    - `mlx_hook()` calls a user-made function that calls `mlx_loop_end()`
  - **Observations**:
    - Cleaning and freeing functions must be called in main after `mlx_loop()`.
- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/e_end_loop_esc_keydown.c mlx/libmlx.a -o t3_end_loop_esc -lXext -lX11 
  ```
- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t3_end_loop_esc
  ```

#### E.3.2 | Call `mlx_destroy_window()` using a flag.

>[!CAUTION]
>`mlx_hook()` runs DURING event processing, so calling `mlx_destroy_window()` can lead to use-after-free error since `mlx_loop()` still holds a ptr to the newly destroyed window

>[!TIP]
>`mlx_loop_hook()` runs BETWEEEN iterations, when no event is being handled, so calling `mlx_destroy_window()` there is safer

So, another way to handle clean exit feature without directly calling `mlx_loop_end()`:
1. Create a struct with 3 members:
  - 1.1 | `void *mlx_ptr`: pointer to display's ID init by `mlx_init()`.
  - 1.2 | `void *win_ptr`: ptr to window's ID init by `mlx_new_window()`.
  - 1.3 | `int window_should_be_destroyed`: flag init at 0, increase when event leading to windows destruction occures.
2. Create functions that increment the flag called by the `mlx_hook()` when:
  - 2.1 | key `[ESC]` is pressed down --> `mlx_hook(dt.win_ptr, 17, 0, &increment_close_win_flag, &dt);`
  - 2.2 | window's `[X]` buttin is clicked on --> `mlx_hook(dt.win_ptr, 2, (1L << 0), &handle_input, &dt);`
3. Create the function called by `mlx_loop_hook()` that will actually called `mlx_destroy_window()`

- **File**: [src/e_dest_win_with_flag.c](https://github.com/alterGNU/mlx_lab/blob/main/src/e_dest_win_with_flag.c)
  - **Objectifs**:
    - handling clean exit when `[ESC]`key pressed AND `[X]`window button clicked.
  - **Implementation**:
    - Call `mlx_destoy_window()` in the `mlx_loop_hook()` function, using a flag store in data.
- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/e_dest_win_with_flag.c mlx/libmlx.a -o t3_esc_and_dest_with_flag -lXext -lX11 
  ```
- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t3_esc_and_dest_with_flag
  ```

## F | Drawing Images
### F.1 | Writing pixels to an image:
#### F.1.a | Color
They're several ways of representing colors, minilibx use the **true color (32-bit)** standard.

- Has we need to fit the color into a `int datatype` to be a 32bits in our system:
  - `int color = 0xTTRRGGBB;`

>[!NOTE]
> We do not need to change the T:Transparency since minilibx seems to ignore this , first byte remain 00.

- `int color = 0x00RRGGBB;`

>[!WARNING]
> Out of range value color bits combined with bit shifting can result in corrupts adjacent color bits

- **LONG IMPLEMENTATION**:
  ```c
  /**
   * shorter version is: val_not_in_range(int v){ return (v < 0 || v > 255);};
   */
  int val_not_in_range(int v)
  {
    if (0 <= v && v <= 255)
      return (0);
    return (1);
  }
  /**
   * if bit color out of range, replace by 0 
   */
  int convert_to_rgb(int r, int g, int b)
  {
    if (val_not_in_range(r))
      r = 0;
    if (val_not_in_range(g))
      g = 0;
    if (val_not_in_range(b))
      b = 0;
    return (r << 16 | g << 8 | b)
  }
  ```

>[!TIP]
> Using masks can clamped to 8bits automatically-->safer, no adjacent color bits corruption when out of range.

- **SHORT IMPLEMENTATION**: RGB components are masked to 8bits before shifting to prevent overflow and sign-extension issues:
  ```c
  int convert_to_rgb(int r, int g, int b)
  {
    return ((r & 0xFF) << 16 | (g & 0xFF) << 8 | (b & 0xFF));
  }
  ```

#### F.1.b | mlx_pixel_put(): (slow)
-  To draw pixels, mlx have the `int mlx_pixel_put(void *mlx_ptr, void *win_ptr, int x, int y, int color)`

    ```c
    /**
      * Put a pixel on the screen.
      *
      * @param	void *mlx_ptr : the mlx instance pointer;
      * @param	void *win_ptr : the window instance pointer;
      * @param	int  x        : the x coordinate of the pixel to draw;
      * @param	int  y        : the y coordinate of the pixel to draw;
      * @param	int  color    : the color of the pixel to draw (0xTTRRGGBB);
      * @return	              : NO RETURN VALUE
      */
    int		mlx_pixel_put(void *mlx_ptr, void *win_ptr, int x, int y, int color);
    ```

- **File**: [src/f_color_panel_PixByPix_slow.c](https://github.com/alterGNU/mlx_lab/blob/main/src/f_color_panel_PixByPix_slow.c)
  - **Objectifs**:
    - Displays a color panel (Red-Green) pixel by pixel slowly.
  - **Implementation**:
    - Clean exit on `[ESC]` key or `[X]` window close (using `mlx_loop_end()`)
    - Use `mlx_pixel_put()` in the `mlx_loop_hook()`:
      - Instead of drawing the entire panel at once, it updates each pixel individually resulting in a slow rendering effect.
  - **Observations**:
    - This approach is inlefficient and results in a very slow rendering.
    - Hook like Clean-Exit can be ignored if occured during the drawing process. 

- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/f_color_panel_PixByPix_slow.c mlx/libmlx.a -o t4_col_pan_slow -lXext -lX11 
  ```

- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t4_col_pan_slow
  ```