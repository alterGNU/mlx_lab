# mlx_lab: Minilibx laboratory

## A | SCRIPTS

### A.1 | `install_mlx.sh`: Install minilibx on linux.

```bash
git clone https://github.com/alterGNU/mlx_lab.git && cd mlx_lab && ./install_mlx.sh
```
- Main steps:
  - step 0: Exec the script as sudo
  - step 1: Check and install this script's dependencies (cmds:date, git, perl, sed, yes).
  - step 2: Update and Upgrade the system (skippable step, but good practice before any installation).
  - step 3: Check and install mlx's dependencies (MLX_DEPS var. , check minilibx README to update list).
  - step 4: Clone and Make minilibx (MLX_PATH var. can be change to modify path and mlx folder's name).
  - step 5: Create a env_file, sourcing this file will add mlx's doc to man cmd (using MANPATH env-var).

- Two files are generated by this script:
  - `<script_parent_dir>/env_file` --> contain the new MANPATH value (need to be manually sourced to add mlx's doc to `man`).
  - `<script_parent_dir>/<date><time>.log` --> each exec. generates a log file that contains all cmds output details.

### A.2 | `clean.sh`: clean mlx_lab folder.
```bash
cd mlx_lab && ./clean.sh
```
- Main steps:
  - step 1: Remove scripts generated files (`env_file` and `*.log` files)
  - step 2: Remove sub-folders in list `SUB_FOLDERS_TO_DEL=( "mlx" )`
  - step 3: Remove binary tests files (pattern:`t[0-9]_*`)
  - step 4: For `src/<folders>` with Makefile, run `make -C ./src/<folders> fclean`

## B | Add mlx to another project's Makefile:
- B.1 | Rules to git clone mlx and make minilibx.
    ```bash
    MLX_DIR =	./mlx
    MLX_A   =	$(MLX_DIR)/libmlx.a
    MLX_URL =	https://github.com/42Paris/minilibx-linux.git
    $(NAME): $(MLX_A) ...
      ...
    $(MLX_A):
        if [ ! -d ${MLX_DIR} ];then git clone $(MLX_URL) $(MLX_DIR); fi
        make -C $(MLX_DIR)
    ```
- B.2 | Update compilation rules:
  - B.2.1 | Add mlx flags:`-lX11 -lXext -lm`
  - B.2.2 | Add static lib:`<path_to>/libmlx.a`
  - B.2.3 | Add header's folder:`-I<path_to_folder_that_contains_mlx.h>`
  ```bash
  MLX_DIR = ./mlx
  MLX_A   = $(MLX_DIR)/libmlx.a
  F_ADD   = -lX11 -lXext -lm
  FLAGS   = -Wall -Wextra -Werror -I. -I$(MLX_DIR)
  $(NAME): $(MLX_A) $(OBJ)
	  cc $(FLAGS) $(OBJ) $(MLX_A) -o $(NAME) $(F_ADD)
  %.o: %.c
	  cc $(FLAGS) -c $< -o
  ```

> [!WARNING]  
> Modern linker `ld >= 2.40`, order is strict: `$(OBJ) < $(MLX_A) < $(F_ADD)`

- B.3 | Update clean and fclean rules:
  ```bash
  clean:
    ...
    make -C $(MLX_DIR) clean
  fclean:
    ...
	  if [ -d $(MLX_DIR) ];then rm -rf $(MLX_DIR);fi
  ```

## C | mlx's basic init and free functions

### C.1 | Starting point of any MLX program: `void *mlx_init()`

This function creates a **connection** between your program and your computer's **display server**.

- **Return value**:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*mlx_ptr)...PANIC`
  - ON SUCCESS return a `mlx_ptr` --> used by all other MLX functions(~ACCESS ID OF DISPLAY SERVER)
- **Freeing**: 
  ```c
  void *mlx_ptr = mlx_init();
  ...
  mlx_destroy_display(mlx_ptr);
  free(mlx_ptr);
  mlx_ptr = NULL;
  ```

### C.2 | Manage windows: `void *mlx_new_window(void *mlx_ptr, int x, int y, char *title)`

This function asks the **display server** to create a new window.

- **Return value**:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*win_ptr)...PANIC`
  - ON SUCCESS return a `win_ptr` --> used by other windows functions(~WINDOW ID)
- **Freeing**:
  ```c
  void *win_ptr = mlx_new_window(mlx_ptr, 400, 800, "titre");
  ...
  mlx_destroy_window(mlx_ptr, win_ptr);
  win_ptr = NULL;
  ```
- **File**: [src/c_basic_init_free_window.c](https://github.com/alterGNU/mlx_lab/blob/main/src/c_basic_init_free_window.c)
  - **Objectifs**:
    - Manipulate display and window's basic fun. and check leaks with valgrind.
  - **Implementation**:
    - Call display's `mlx_init()` and `mlx_destroy_display()` fun.
    - Call window's `mlx_new_window()` and `mlx_destroy_window()` fun.
  - **Observations**:
    - `mlx_destroy_display()` **does not free** `mlx_ptr` pointer var., setting to null is also needed.
    - `mlx_destroy_window()` **frees** `win_ptr` pointer var., but setting at null needed.
    - Without a loop, nothing displayed on screen (too fast/quick).
- **Compilation**:
  ```c
  cc -Wall -Wextra -Werror -Imlx src/c_basic_init_free_window.c mlx/libmlx.a -o t1_win -lXext -lX11 
  ```
- **Valgrind**:
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t1_win
  ```

> [!CAUTION]
> mlx_new_window triggers the Valgrind warning, add `--undef-value-errors=no` flags to delete false-negative warnings.

### C.3 | Manage images: `void *mlx_new_image(void *mlx_ptr, int x, int y)`

This function creates a new image in memory. 

- **Return value**:
  - ON FAILURE return NULL --> do not forget to protect with `if (!*img_ptr)...PANIC`
  - ON SUCCESS return a `img_ptr` --> used by other manipulating images functions(~IMAGES ID)
- **Freeing**:
  ```c
  void *img_ptr = mlx_new_image(mlx_ptr, 1920, 1080);
  ...
  mlx_destroy_image(mlx_ptr, img_ptr);
  img_ptr = NULL;
  ```
- **File**: [src/c_basic_init_free_image.c](https://github.com/alterGNU/mlx_lab/blob/main/src/c_basic_init_free_image.c)
  - **Objectifs**:
    - Manipulate image basic fun (creation and deletion)
  - **Implementation**:
    - Call window's `mlx_new_image()` and `mlx_destroy_image()` fun.
  - **Observations**:
    - `mlx_destroy_image()` **frees** `img_ptr` pointer var., but setting at null needed.
    - Without a loop, nothing displayed on screen (too fast/quick).
- **Compilation**:
  ```c
  cc -Wall -Wextra -Werror -Imlx src/c_basic_init_free_image.c mlx/libmlx.a -o t1_img -lXext -lX11 
  ```
- **Valgrind**:
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t1_img
  ```

## D | Display image `mlx_loop()`
In previous code examples, our newly created window or image are not displayed on screen

_(Actually, they're displayed, but too quickly to be seen and then are destroyed)._

To fix this, a **'naive approach'** would have been to use a `while (true){...}` loop between init. and destruction.

A better way is to use the Minilibx provided `int mlx_loop(void *mlx_ptr)` function that handles events while looping infinitely.

_(This way, we can associate user-defined functions with events (exit loop when `[ESC]` key is pressed...)_

> [!NOTE]
> loop stop if `xvar->window_count < 1`:no window left(destroyed) or `xvar->end_loop > 0`:fun.`mlx_loop_end(mlx_ptr)`called

- **File**: [src/d_display_window.c](https://github.com/alterGNU/mlx_lab/blob/main/src/d_display_window.c)
  - **Objectifs**:
    - display the newly created window by adding a loop. _(destruction fun. wait the end of the loop)_
  - **Implementation**:
    - Calls `mlx_loop()` between window's creation and destruction funs.
  - **Observations**:
    - This time, a window is displayed, but without hook on clean-exit fun., only `Ctrl+C` can kill the program, leading to leaks!
- **Compilation**:
  ```c
  cc -Wall -Wextra -Werror -Imlx src/d_display_window.c mlx/libmlx.a -o t2_win -lXext -lX11 
  ```
- **Valgrind**:
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t2_win
  ```

> [!WARNING]
> Without event, loop can only be stopped with `[CTRL]+[C]` --> leaks!!!

## E | Events
### E.1 | X11 Interface - Events
X-Window system is **bi-directional**:
  - The program sends orders to the screen to display pixels/images/...
  - The program can get information from keyboard/mouse associated to the screen by receiving **events** from keyboard/mouse

Each event has an **int ID** and can be combined with a mask (int ID too) to whitelist or blacklist events.

- [Off. Docs: X11 events](https://tronche.com/gui/x/xlib/events/)

#### E.1.1 | events ID/KEY
```c
enum {
	ON_KEYDOWN = 2,
	ON_KEYUP = 3,
	ON_MOUSEDOWN = 4,
	ON_MOUSEUP = 5,
	ON_MOUSEMOVE = 6,
	ON_EXPOSE = 12,
	ON_DESTROY = 17
};
```
### E.2 | MinilibX API - Events
#### E.2.1 | Generic Access to X11-Event: `mlx_hook()`
- `int	mlx_hook(void *win_ptr, int x_event, int x_mask, int (*funct)(), void *param)`
  - `void *win_ptr`   : ptr to the window on which this assignment is specific
  - `int x_event`     : event id
  - `int x_mask`      : mask id
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

MLX therefore handle event with **mlx_hook aliases**:

#### E.2.2 | Alias to manage NO EVENT `mlx_loop_hook(win_ptr, fun, arg)`:
- When **NO EVENT** `int	mlx_loop_hook(t_xvar *xvar,int (*funct)(),void *param)` run:
  - `t_xvar *xvar`    : t_xvar struct (window id) on which this assignment is specific
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

> [!TIP]
> This mlx_hook alias function can be use to draw when no event detected.

#### E.2.3 | Alias to manage KEYUP pressing event: `mlx_key_hook(win_ptr, fun, arg)`
- When **a key is pressed** use alias: `int	mlx_key_hook(t_xvar *xvar,int (*funct)(),void *param)` run:
  - `t_xvar *xvar`    : t_xvar struct (window id) on which this assignment is specific
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

#### E.2.4 | Alias to manage MOUSE button pressing event: `mlx_mouse_hook(win_ptr, fun, arg)`
- When **the mouse is pressed** use alias: `int	mlx_mouse_hook(t_xvar *xvar,int (*funct)(),void *param)` run:
  - `t_xvar *xvar`    : t_xvar struct (window id) on which this assignment is specific
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

#### E.2.5 | Alias to manage EXPOSE event: `mlx_expose_hook(win_ptr, fun, arg)`
- When **a part of the window should be redraw**, use alias: `int	mlx_expose_hook(t_xvar *xvar,int (*funct)(),void *param)` run:
  - `t_xvar *xvar`    : t_xvar struct (window id) on which this assignment is specific
  - `int (*funct)()`  : ptr to the fun. you want to be called when an event occurs
  - `void *param`     : ptr who will be passed to the fun. (should be used to store the parameters needed by fun.)

### E.3 | Examples with : Clean Exit Features
#### E.3.1 | Call `mlx_loop_end()` directly

>[!NOTE]
> This way is simpler, it will just stop the loop: just call cleaning functions in main after `mlx_loop()` calls.

##### E.3.1.a | On event Window's `[X]` Button.

**Clean Exit** when event: click on `[X]` windows --> `mlx_loop_end()` --> stop `mlx_loop()`

- **File**: [src/e_end_loop_destroy_window.c](https://github.com/alterGNU/mlx_lab/blob/main/src/e_end_loop_destroy_window.c)
  - **Objectifs**:
    - Displaying a window until the window's `[X]` Button clicked-on-->clean-exit!
  - **Implementation**:
    - Hook `[X]`Window's-Button with `mlx_hook()`-->calls `mlx_loop_end()` function.
  - **Observations**:
    - Cleaning and freeing functions must be called in main after `mlx_loop()` since `mlx_loop_end()` just stop the `mlx_loop()` fun.
- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/e_end_loop_destroy_window.c mlx/libmlx.a -o t3_end_loop_dest_win -lXext -lX11 
  ```
- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t3_end_loop_dest_win
  ```

##### E.3.2.b | On event Pressing Key `[ESC]` Down.

**Clean Exit** when event: press down `[ESC]` key --> `mlx_loop_end()` --> stop `mlx_loop()`

- **File**: [src/e_end_loop_esc_keydown.c](https://github.com/alterGNU/mlx_lab/blob/main/src/e_end_loop_esc_keydown.c)
  - **Objectifs**:
    - Handling clean exit by pressing down `[ESC]` key: unsing `mlx_loop_end()`
  - **Implementation**:
    - `mlx_hook()` calls a user-made function that calls `mlx_loop_end()`
  - **Observations**:
    - Cleaning and freeing functions must be called in main after `mlx_loop()`.
- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/e_end_loop_esc_keydown.c mlx/libmlx.a -o t3_end_loop_esc -lXext -lX11 
  ```
- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t3_end_loop_esc
  ```

#### E.3.2 | Call `mlx_destroy_window()` using a flag.

>[!CAUTION]
>`mlx_hook()` runs DURING event processing, so calling `mlx_destroy_window()` can lead to use-after-free error since `mlx_loop()` still holds a ptr to the newly destroyed window

>[!TIP]
>`mlx_loop_hook()` runs BETWEEEN iterations, when no event is being handled, so calling `mlx_destroy_window()` there is safer

So, another way to handle clean exit feature without directly calling `mlx_loop_end()`:
1. Create a struct with 3 members:
  - 1.1 | `void *mlx_ptr`: pointer to display's ID init by `mlx_init()`.
  - 1.2 | `void *win_ptr`: ptr to window's ID init by `mlx_new_window()`.
  - 1.3 | `int window_should_be_destroyed`: flag init at 0, increase when event leading to windows destruction occures.
2. Create functions that increment the flag called by the `mlx_hook()` when:
  - 2.1 | key `[ESC]` is pressed down --> `mlx_hook(dt.win_ptr, 17, 0, &increment_close_win_flag, &dt);`
  - 2.2 | window's `[X]` buttin is clicked on --> `mlx_hook(dt.win_ptr, 2, (1L << 0), &handle_input, &dt);`
3. Create the function called by `mlx_loop_hook()` that will actually called `mlx_destroy_window()`

- **File**: [src/e_dest_win_with_flag.c](https://github.com/alterGNU/mlx_lab/blob/main/src/e_dest_win_with_flag.c)
  - **Objectifs**:
    - handling clean exit when `[ESC]`key pressed AND `[X]`window button clicked.
  - **Implementation**:
    - Call `mlx_destoy_window()` in the `mlx_loop_hook()` function, using a flag store in data.
- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/e_dest_win_with_flag.c mlx/libmlx.a -o t3_esc_and_dest_with_flag -lXext -lX11 
  ```
- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t3_esc_and_dest_with_flag
  ```

## F | Drawing Images
### F.1 | Basic concepts:
To understand and manipulate pixels, a few concepts need to be clarified:
- a | Color depth, `bpp` and pixel color representation in memory
- b | Converting TRGB color representation to int 32-bit integer
- c | Endianness
- d | Image representation in memory
- e | Padding

#### **F.1.a)** <ins>Color depth,`bpp` and representation in memory:</ins>

The **color depth** describes how many **bits are used to represent the color of a single pixel**

It is usually expressed as `bpp` **(Bits-Per-Pixel):
- `bpp` determines how many **distinct colors** a pixel can represent:
  - bpp = 1 --> 2^1 = 2 colors (monochrome)
  - bpp = 2 --> 2^2 = 4 colors
  - bpp = 4 --> 2^4 = 16 colors
  - bpp = 8 --> 2^8 = 256 colors
  - bpp = 16 --> 2^16 = 65,536 colors (Highcolor)
  - bpp = 24 --> 2^24 = 16,777,216 colors (Truecolor)

- According to the Minilibx's README, images that we use are in the color depth:**32-bit Truecolor format**:
  - 24-bits (3bytes) for the color components: R,G and B
  - 8-bits (1bytes) unused or used for the alpha (Transparency) channel

- A pixel color is represented as a **32-bits integer**, *(4bytes == 32bits)*, usually written in **TRGB** format:
  - `int pixel_color = 0xTTRRGGBB;`

>[!NOTE]
> In minilibx, the transparency byte is generally left unchanged at value of `0x00` == 0,  means fully opaque *(while `0xFF` == 255, means fully transparent)*.

  - `int pixel_color = 0x00RRGGBB;`

#### **F.1.b)** <ins>Convert TRGB to 32-bit integer:</ins>

To convert our 3 RGB integer value into one 32-bit integer, we can use **bitshifting** operation in C *(left shift)*, 

Since R,G or B values are in range `base 10=[0:255]<=>base hex=[00:FF]--> 256 values`, they can each be represented/stored in one byte as we saw earlier.

>[!WARNING]
> R,G or B out of range values color bits combined with bit shifting can result in corrupts adjacent color bits

- **LONG IMPLEMENTATION**: makes sure R,G or B values are in `00` to `FF` range using **modulo operator**, then convert to a 4bytes integer
  ```c
  // force x to be in [0:255] range (force to be a null or positive number lesser than 256)
  int clamped_to_8bits(int x) { return (((x % 256) + 256) % 256)); }

  // convert 3 int into 1 int (=4bytes) using bit shifting since 1Byte can store a R,G or B value
  int convert_to_rgb(int r, int g, int b)
  {
    return (clamped_to_8bits(r) << 16 | clamped_8bits(g) << 8 | clamped_to_8bis(b));
  }
  ```

>[!TIP]
> Using masks can clamped to 8bits automatically-->safer, no adjacent color bits corruption when out of range.

- **SHORT IMPLEMENTATION**: RGB components are **masked** to 8bits before shifting to prevent overflow and sign-extension issues leading to color corruption
  ```c
  int convert_to_rgb(int r, int g, int b) { return ((r & 0xFF) << 16 | (g & 0xFF) << 8 | (b & 0xFF)); }
  ```

#### **F.1.c)** <ins>Endianness:</ins>

**Endianness** is a fundamental part of how computers read and understand **bytes**: it's the **order** in which **multi-byte values** are **stored in memory**.

*We usually do not have to know an image's endianness...each computer is internally consistent for their own data and handle internally all image's access memory manipulations*

>[!NOTE]
> Endianness matters only if you manually have to manipulates bytes *(getting or setting pixel's value bit-by-bit)*

Endianness is primarily expressed as:
- **Big-Endian (BE)**: Left-to-Right
  - **Used by/for**: Network protocols
  - **Store**: **B**ig-**E**nd first:
    ```c
    // int HEX memory representation
    int pixel_color = 0x00RRGGBB;
    //Address -> +0 +1 +2 +3
    //Memory  -> 00 RR GG BB
    unsigned char *p = (unsigned char *)&pixel_color;
    p[0]; // -> 00
    p[1]; // -> RR
    p[2]; // -> GG
    p[3]; // -> BB
    ```
    - When reading multiple bytes, the first byte is the biggest, and last the lowest
- **Little-Endian (LE)**: Right-to-Left
  - **Used by/for**: (x86 architecture)
  - **Store**: **L**ittle-**E**nd first:
    ```c
    // int HEX memory representation
    int pixel_color = 0x00RRGGBB;
    //Address -> +0 +1 +2 +3
    //Memory  -> BB GG RR TT
    unsigned char *p = (unsigned char *)&pixel_color;
    p[0]; // -> BB
    p[1]; // -> GG
    p[2]; // -> RR
    p[3]; // -> 00
    ```
    - When reading multiple bytes, the first byte is the lowest, and last the biggest

>[!CAUTION]
> Only the byte order in RAM is changed, NOT THE INTEGER'S VALUE, (`int pixel_color` stays the same in BE or LE cases!!).


#### **F.1.d)** <ins>Image representation:</ins>

Lets start by stating some obvious, but fundamental, ideas:

- An **image** can be seen as a **two-dimensional** structure composed of **one-dimensional elementary units**:
  - Real world: pigments(1D) distributed on a surface(2D)
  - Math world: points(actually 0D, but discret units ^^') arranged on a plane(2D)
- In a computer's world *(a binary world)*:
  - The most elementary unit is the **bits**, which can have only two values: `0` or `1`.
  - We, programmers, manipulate another units calls **bytes** which correspond of a **group of 8 bits**
- For a computer, an image's elementary units is called a **pixel**, and is seen as a **fixed-size set of bits** *(an int of 32-bits in our case)*
  - A pixel represents the **color of a single point** in the image.
    - its position in the pixel's array correspond to the location in the 2D image representation of the **point:(x, y)**
    - its value, a 4-bytes integer, correspond to **point**'s color.

Although an image is conceptually **two-dimensional**, a computer memory is **linear**:
- So, to represent an image in a computer's world as we do in real or math world, we can use an array of integer: `int img[with][height]` *(2D int array)*
- But a computer's memory is a linear buffer of bytes `int *buff` *(~ 1D int array)*, so there an image 2D integer array become a 1D integer array where **pixels laid out line by line in a contiguous block of memory**.

>[!NOTE]
>As we know, both of these two objects(pixel and integer array) need extra informations to be manipulated so a **raw memory buffer** alone is not enough to describe an image...

This ray memory buffer is not sufficient to describe an image, we also need **meta-data**:
- Pixel-related information:
  - **B**ytes-**P**er-**P**ixel: size of a single pixel in memory *(size of the unit array memory block)* `bpp / 8`
  - **Endianness**: order to get/set color manually in memory
- Image dimensions *(~2D array of pixel)*:
  - **width (x)**: number of pixels per line
  - **height(y)**: number of lines
- Memory layout:
  - **line len**: Number of bytes used to store a single row of pixels in memory

>[!CAUTION]
> Here **image's height** and **line len** seem to refer to the same dimension (y), but in practice, these two values differ due to the **structure optimization concept called: PADDING**

All these lead to our final *(and very simply ^^)* digital image representation as a data structure composed of a **pixel array** and its **meta-data**:
  ```c
  typedef struct s_img
  {
    char *ptr_img;      // pointer to image data (first bit of the first image's pixel)
    int endianness;     // data byte order
    int bits_per_pixel; // bits per pixel
    int img_width;      // image dim. [x] (nb of pixels per line)
    int img_height;     // image dim. [y] (nb of line)
    int bytes_per_line; // len(line) in byte == accelerator to next line
  } t_img
  ```

*(This is a very simplified representation of how I mentally represent a digital image structure in a computer's memory.)*

##### <ins>**In conclusion**:</ins>
- An image can also be seen as a 2D structure in the computer's world, but through a **mathematical abstraction**:
  - this 2D object can be reconstructed using calculations.
- In a computer's memory, an image is a structure stored as a **linear memory buffer** composed of contiguous bytes. *(~1D bit array)*

>[!TIP]
> This is exaclty what `mlx_get_data_add()` provides, a way to extract the meta-data needed to manipulate the **linear memory buffer (1D)** like a **2D image representation**.

#### **F.1.e)** <ins>Padding:</ins>
In our image struct, **line length** and **image height** seems redondant...but it's not quit the same thing because:
- ✅ **pixels** inside a row **are** stored **contiguously**
- ❌ **rows** themselves **are not** guaranteed to be stored **contiguously** *(not be tightly packed in memory...)*:
  - last bit of last pixel of N'th line not necessarly next to the first bit of the first pixel of the N+1'th line.

In practice, each row of pixels occupies a number of bytes called **line length** *(a.k.a stride)* often **greater than** `image width * (bpp / 8)`.

The extra bytes at the end of each row are called **padding** and exist only to **align memory correctly** to a **multiple of 4 bytes** *(along with [struct. alignment and data-packing, padding](https://www.geeksforgeeks.org/c/structure-member-alignment-padding-and-data-packing/) are used in order to improve CPU, GPU and cache performance)*

>[!WARNING]
> The padding bytes DO NOT represent pixels and MUST BE SKIPPED when moving from one row to the next

- ❌ Without padding:
  - **line_lenght** == **image_height**
  - to get a pixel(x,y) position in buffer:
    ```c
    // line_length = image_height + 0 ...
    pix_add = img_add + (y * img_height) + (x * bpp / 8)`;
    ```
- ✅ With padding:
  - **line_lenght** >= **image_height**
  - to get a pixel(x,y) position in buffer:
    ```c
    // line_length = image_height + padding
    pix_add = img_add + (y * line_lenght) + (x * bpp / 8)`;
    ```

### F.2 | ❌ mlx_pixel_put(): (slower-->not recommended)
-  To draw pixels, mlx have the `int mlx_pixel_put(void *mlx_ptr, void *win_ptr, int x, int y, int color)`

    ```c
    /**
      * Put a pixel on the screen.
      *
      * @param	void *mlx_ptr : the mlx instance pointer;
      * @param	void *win_ptr : the window instance pointer;
      * @param	int  x        : the x coordinate of the pixel to draw;
      * @param	int  y        : the y coordinate of the pixel to draw;
      * @param	int  color    : the color of the pixel to draw (0xTTRRGGBB);
      * @return	              : NO RETURN VALUE
      */
    int		mlx_pixel_put(void *mlx_ptr, void *win_ptr, int x, int y, int color);
    ```

>[!IMPORTANT]
> `mlx_pixel_put()` draws directly on the window, without waiting for the frame to be entirely rendered...

- **File**: [src/f_pixBypix_randcolor_slow.c](https://github.com/alterGNU/mlx_lab/blob/main/src/f_pixBypix_randcolor_slow.c)
  - **Objectifs**:
    - Displays a random colors image.
  - **Implementation**:
    - Clean exit on `[ESC]` key or `[X]` window close (using `mlx_loop_end()`)
    - Use `mlx_pixel_put()` in the `mlx_loop_hook()`:
      - Instead of drawing the entire panel at once, it updates each pixel individually resulting in a slow rendering effect.
  - **Observations**:
    - This approach is **inefficient** and results in a very slow rendering.
    - Hook like Clean-Exit can be **ignored** if occurred during the drawing process. 

- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/f_pixBypix_randcolor_slow.c mlx/libmlx.a -o t4_randcol_slow -lXext -lX11 
  ```

- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t4_randcol_slow
  ```

>[!TIP]
> This can be fixed by buffering all of our pixels to an image, then pushing the image to the window

### F.2 | ✅ using an image & create our own fun.(): (faster-->recommended)

#### F.2.a | ADD image: Modify `t_data *dt` struct to store image's members
As we saw previously, images are struct and mlx provides fun. to manipulates them:

1. In t_data add image's struct members:
  ```c
  typedef struct s_data
  {
  	void	*mlx_ptr;
  	void	*win_ptr;
  	void	*img_ptr;   // -> pointer to image's struct
  	char	*addr;      // -> pointer to the first image's pixel (x, y)= (0, 0) <=> first int array's cell <=> image's top left corner pixel
  	int		bpp;        // -> Bits-Per-Pixels (to get bytes-per-pixels = bpp / 8)
  	int		size_line;  // -> size of array's line = (image_heigth + padding)
  	int		endian;     // -> 0 if little-endian, 1 if big-endian
  }	t_data;
  ```
2. t_data functions to create image and set all image's struct members
  ```c
  init_data()
  {
    ...
    dt.img_ptr = mlx_new_image(dt.mlx_ptr, WIN_X, WIN_Y);
    ...
    dt.addr = mlx_get_data_addr(dt.img_ptr, &dt.bpp, &dt.size_line, &dt.endian);
    ...
  }
  ```

#### F.2.b | Create our own function to draw pixel on the image:

>[!IMPORTANT]
> Instead of drawing directly on windows, create a fun. that will put pixel-by-pixel in an image.

```c
void	put_pixel_to_image(t_data *dt, int x, int y, int color)
{
	char	*pixel;
	int		i;

	pixel = dt->addr + (y * dt->size_line + x * (dt->bpp / 8));
	i = dt->bpp - 8;
	while (i >= 0)
	{
		if (dt->endian != 0)
			*pixel++ = (color >> i) & 0xFF;
		else
			*pixel++ = (color >> (dt->bpp - 8 - i)) & 0xFF;
		i -= 8;
	}
}
```

#### F.2.c | Import/Push the edited image to the window: `mlx_put_image_to_window()`

>[!NOTE]
> `draw_randcolor_image()` is called directly by `mlx_loop_hook()`--> executed at each loop

```c
int	draw_randcolor_image(t_data *dt)
{
	int	x;
	int	y;
	int	color;

	if (!dt->mlx_ptr || !dt->win_ptr)
		return (printf("Error: Invalid data pointers\n"), 1);
 // PART1: Create a random colored image
	color = create_random_color();
	x = -1;
	while (++x < WIN_X)
	{
		y = -1;
		while (++y < WIN_Y)
			put_pixel_to_img(dt->mlx_ptr, dt->img_ptr, x, y, color);
	}
 // PART2: Put the newly created image to the window
	mlx_put_image_to_window(dt->mlx_ptr, dt->win_ptr, dt->img_ptr, 0, 0);
	return (0);
}
```

- **File**: [src/f_pixBypix_randcolor_fast.c](https://github.com/alterGNU/mlx_lab/blob/main/src/f_pixBypix_randcolor_fast.c)
  - **Objectifs**:
    - Displays a random colors image without delay.
  - **Implementation**:
    - Clean exit on `[ESC]` key or `[X]` window close (using `mlx_loop_end()`).
    - Use `put_pixel_to_image()` that draw each pixel on the image and once done.
    - Once entire image buffered, `draw_randcolor_image()` push the image to the window.
  - **Observations**:
    - This approach is more complex, but way faster for large images.
    - The drawing process is done in memory, then displayed in one go.

- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/f_pixBypix_randcolor_fast.c mlx/libmlx.a -o t4_randcol_fast -lXext -lX11 
  ```

- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t4_randcol_fast
  ```

## G | Minilibx and File-Formats

### G.1 | File-Formats and compression

Two important concepts for understanding digital images are **File Formats** and **Image Compression** *(data compression applied to digital images)*.

- **File formats** are **specifications** that describe how image data and meta-data are **encoded and stored in a file**.

>[!CAUTION]
> File Formats describe how images are stored on DISK.

As we can imagine:

- The goal of **data compression** is to **reduce data size** by encoding information using **fewer bits than the original representation**
- The goal of **image compression** is to **reduce the size of image data** using algorithms that take advantage of **statistical redundancy** in pixel values.

There are two types of algorithms used for image-compression, **lossy** and **lossless**.
*(here some examples of algorithms and the file formats that use them)*

#### G.1.a | lossy compression:
<ins>[lossy compression](https://en.wikipedia.org/wiki/Lossy_compression)</ins>: irreversible compression that results in **loss of information**.

- [Discrete-Cosine-Transformation](https://en.wikipedia.org/wiki/Discrete_Cosine_Transform) uses **fourier Transformation**, used in most digital media:
  - [.jpeg](https://en.wikipedia.org/wiki/JPEG)
  - [.heic](https://en.wikipedia.org/wiki/High_Efficiency_Image_File_Format)
- [Color quantization](https://en.wikipedia.org/wiki/Color_quantization) reduces the number of colors used in an image:
  - [.gif](https://en.wikipedia.org/wiki/GIF)
  - [.png](https://en.wikipedia.org/wiki/PNG) *(optional, palette-based)*

#### G.1.b | lossless compression:
<ins>[lossless compression](https://en.wikipedia.org/wiki/Lossless_compression)</ins> : compression where decompression reconstructs the original image exactly.

- [Run-Length encoding](https://en.wikipedia.org/wiki/Run-length_encoding): consecutive occurrences are stored as a single occurrence and a count -> `len("ABBCCCDDDDEEEEEFFFFFFGGGGGGGHHHHHHHH")=36`-->`len("A1B2C3D4E5F6G7H8")=16`
  - [.xpm](https://en.wikipedia.org/wiki/X_PixMap)
  - [.gif](https://en.wikipedia.org/wiki/GIF)
  - [.png](https://en.wikipedia.org/wiki/PNG) *(optional)*
  - [.tga](https://en.wikipedia.org/wiki/Truevision_TGA)
  - [.tiff](https://en.wikipedia.org/wiki/TIFF)
- [Entropy coding](https://en.wikipedia.org/wiki/Entropy_coding) a family of techniques that represent data using as few bits as possible, based on symbols frequency:
  - [Arithmetic coding](https://en.wikipedia.org/wiki/Arithmetic_coding) encodes the entire message as a single number in the interval `[0, 1)`
    - [.jpeg](https://en.wikipedia.org/wiki/JPEG)
  - [Huffman coding](https://en.wikipedia.org/wiki/Huffman_coding) Based on the fact that not all bit have the same size, encoding using short bit codes to frequent symbols and longer for rarest --> lesser size.
    - [.jpeg](https://en.wikipedia.org/wiki/JPEG)
    - [.png](https://en.wikipedia.org/wiki/PNG)
    - [.tiff](https://en.wikipedia.org/wiki/TIFF)

#### G.1.c | Conversion file-format<-->image data structure
Now that we better understand **image-compression**, we can understand why **file-format** provides:
- A digital image representation (pixel array + meta-data)
- **Compression-related data** allowing:
  - A **decoder** to **decode and decompress** an image **file format** into an **in-memory image structure**.
  - A **encoder** to **encode and compress** an **in-memory image structure** into an image **file format**

>[!CAUTION]
> Encoders/Decoders transform File Format representation to and from raw pixel data in memory.

Minilibx handles **XPM** file formats using the following utility functions:
- `void	*mlx_xpm_file_to_image();` to convert **XPM file** to a new instance of **in-memory image structure**
- `void	*mlx_xpm_to_image();` to convert an instance of **in-memory XPM image structure** to a new **in-memory image structure**

### G.2 | Minilibx with XPM File Format

#### G.2.a | Display a simple 2D maze using XPM images directly on the window.

- **File**: [src/g_2Dmaze_window.c](https://github.com/alterGNU/mlx_lab/blob/main/src/g_2Dmaze_window.c)
  - **Objectifs**:
    - From a 2D maze given as an array of integers, display a window where each type of cell in the array is represented by an XPM image:
      - in order to be able later to move a player's position, a conversion into an integer array is done internally
      - the window is composed of several occurrences of XPM images
  - **Implementation**:
    - Load floor and wall images from XPM files using `mlx_xpm_file_to_image()`
    - Create a maze _(array of integer)_ from a string array.
    - Draw the maze directly onto the window using `mlx_put_image_to_window()`.
    - **HOOK**: _(using `mlx_hook()`)_
      - Clean exit on `[ESC]` key or window close _(calling `mlx_loop_end()`)_
  - **Observations**:
    - This approach is straightforward but may be slower for large mazes since it draws directly to the window pixel by pixel.
    - Without flag, images continuously draw into window:
      - For 02s exec-->  100000 images dawned -->  200000 malloc/free calls.
      - For 04s exec-->  300000 images dawned -->  600000 malloc/free calls.
      - For 10s exec--> 1000000 images dawned --> 2000000 malloc/free calls.
- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/g_2Dmaze_window.c mlx/libmlx.a -o t5_maze_win -lXext -lX11 
  ```
- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t5_maze_win
  ```

#### G.2.b | Display a simple 2D maze using XPM images on a buffer image.

The idea here is to create a buffer image by inserting images of the floor and walls, and then display this buffer image in the window once..._(limiting calls of fun. `mlx_put_image_to_window` that malloc a gogo)_

To do this, we need to write a function that inserts one image into another by copying, pix-by-pix and at the correct coordinates, the pixels of the source image into the destination image...
  ```c
  int	mlx_xpm_cpy_src_in_dst(t_img *src, t_img *dst, int dst_x, int dst_y)
  {
  	int	x;
  	int	y;
  	int	bpp;
  	int	src_pix;

  	if (!dst || !src || !dst->addr || !src->addr || dst_x < 0 || dst_y < 0)
  		return (printf("Invalid arguments\n"), 1);
  	if (dst_x + src->width > dst->width || dst_y + src->height > dst->height)
  		return (printf("Source image exceeds destination bounds\n"), 1);
  	if (src->bpp != dst->bpp)
  		return (printf("Different bpp not supported\n"), 1);
  	bpp = dst->bpp / 8;
  	x = -1;
  	while (++x < src->height)
  	{
  		y = -1;
  		while (++y < src->width)
  		{
  			src_pix = *(int *)(src->addr + (x * src->size_line + y * bpp));
  			*(int *)(dst->addr + ((dst_y + x) * \
  				dst->size_line + (dst_x + y) * bpp)) = src_pix;
  		}	
  	}
  	return (0);
  }
  ```

- **File**: [src/g_2Dmaze_buffimg.c](https://github.com/alterGNU/mlx_lab/blob/main/src/g_2Dmaze_buffimg.c)
  - **Objectifs**:
    - Same as G.2.a but instead of drawing directly on window, use a buffer image
  - **Implementation**:
    - Load floor and wall images from XPM files using `mlx_xpm_file_to_image()`
    - Create a maze from a string array and a buffer image with the right size
    - Draw the maze on the buffer image, once done put buff_img on window using `mlx_put_image_to_window()`.
    - **HOOK**: _(using `mlx_hook()`)_
      - Clean exit on `[ESC]` key or window close _(calling `mlx_loop_end()`)_
  - **Observations**:
    - Without flag, images continuously drawn, but not directly into window:
      - For 02s exec-->     300 images dawned -->    1500 malloc/free calls.
      - For 04s exec-->     500 images dawned -->    3000 malloc/free calls.
      - For 10s exec-->    1500 images dawned -->    8000 malloc/free calls.
- **Compilation**: 
  ```c
  cc -Wall -Wextra -Werror -Imlx src/g_2Dmaze_buffimg.c mlx/libmlx.a -o t5_maze_buffimg -lXext -lX11 
  ```
- **Valgrind**: 
  ```c
  valgrind --leak-check=full --track-fds=yes --show-leak-kinds=all --undef-value-errors=no ./t5_maze_buffimg
  ```

## H | MGP-MLX: Mini Games Projects with MiniLibX

We will now start from the `src/g_2Dmaze_buffimg.c` program and try to improve it:
- optimization: use less resources
- add features: such as limFPS, raycasting etc...

As our code grows, we will create a folder per major update using multi-files, headers and Makefiles to simplify and organise the code.

### H.1 | ...Optimize image creation by re-drawing image only if player move...

- Program's name        : **xpmMaze_bresenhamGhost_gridBaseMov_busySpin**
  - **xpmMaze**         : The first layer, our maze, is represented use xpm images as tiles.
  - **bresenhameGhost** : The second layer, our player, is represented by a bresenhame circle.
  - **gridBaseMove**    : The player moves **Discretly** : `new_pos(x, y) = old_pos(x +- step, y +- step)`
  - **busySpin**        : _(Spoiler Alert)_ using a flag to draw image only when player moved ended poorly in a **busy-spin**!

>[!NOTE]
> Makefile has a symbolic link rules to create a link to the docs/ folder --> solves relatif xpm file path variable.

#### H.1.a | Games Conditions:
- **2D grid**:
  - User write the grid has a `const char *grid` first _(user-friendly --> easier to write)_
  - String grid convert to an integer array: `t_maze` struct:
    - 1D integer array: `int		*mat;` _(That can be seen as a 2D array through mathematical calculations)_
    - line len        : `int width;`
    - number of lines : `int height;`
  - The grid representation use for each cell, an **XPM** files as tiles. _(~ so long johnson)_
- **Player**:
  - Start position given in string array with the char:`'P'`.
  - A player struct has
    - a position member:`t_pos(float x, float y)` --> 2D position
    - a color member:`int color` --> pixel color `0x00RRGGBB` value
    - a circle radius member:`int radius` --> circle radius in pixel
  - Player representation is a fill color circle. _(The algorithm used to draw a circle in pixels is: **Bresenham**)_
- **Movements**:
  - Player's movement are Grid-Based, meaning that the player moves in **discrete steps aligned to the grid**:
    - Pressing `[W]` key--> increase `player.pos.x` by on **step** <-> Moving North on grid
    - Pressing `[D]` key--> increase `player.pos.y` by on **step** <-> Moving East on grid
    - Pressing `[S]` key--> decrease `player.pos.x` by on **step** <-> Moving South on grid
    - Pressing `[A]` key--> decrease `player.pos.y` by on **step** <-> Moving West on grid
  - They're **NO COLLISIONS** inside grid with walls ==> **GHOST MODE**, but a player can **not move outside the grid**:
    - `0 <= player.pos.x` && `player.pos.x < maze.width`
    - `0 <= player.pos.y` && `player.pos.y < maze.height`

#### H.1.b | Implementations:

- [header.h](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/header.h): header with struct def. and fun. signatures.
- [t_pos_struct.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/t_pos_struct.c)
- [t_player_struct.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/t_player_struct.c)
- [t_maze_struct.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/t_maze_struct.c)
- [t_img_struct.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/t_img_struct.c)
- [t_data_struct.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/t_data_struct.c)
- [draw_to_img.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/draw_to_img.c)
- [hooked_funs.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/hooked_funs.c)
- [utils.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/utils.c)
- [main.c](https://github.com/alterGNU/mlx_lab/blob/main/src/h1/main.c)

#### H.1.c | Commands:
- From pwd = `./mlx_lab/`:
  - Compile and Run Program with Valgrind
    ```c
    make -C ./src/h1 valgrind
    ```
  - Clean
    ```c
    make -C src/h1 fclean
    ```
#### H.1.d | Observations:
- Exec for  2secondes -->   0 steps -->   1 image  drawn -->  45000allocs
- Exec for  2secondes -->  49 steps -->  50 images drawn -->  55000allocs
- Exec for  4secondes -->   0 steps -->   1 image  drawn --> 120000allocs
- Exec for  4secondes -->  85 steps -->  86 images drawn -->  85000allocs
- Exec for 10secondes -->   0 steps -->   1 image  drawn --> 300000allocs
- Exec for 10secondes --> 249 steps --> 250 images drawn --> 250000allocs

#### H.1.e | Conclusions:
Optimization fails poorly: **using a flag reduces drawing operations but not the memory allocations**:
- Image are drawn only when needed, but busy-spin loop is worst than continiously re-drawing the same image when static:
  - When static, `mlx` allocates 30k allocs/second!!!

>[!TIP]
> Using `usleep(16000)` instead of returning could work...lets try to implement FPS limitation using `gettimeofday()`

### H.2 | Add FPS limitation to avoid busy-loop consumming ressources

- Program's name        : **xpmMaze_bresenhamGhost_gridBaseMov_limFPS**
  - **xpmMaze**         : The first layer, our maze, is represented by xpm tiles.
  - **bresenhameGhost** : The second layer, our player, is represented by a bresenhame circle.
  - **gridBaseMove**    : The player moves **Discretly** : `new_pos(x, y) = old_pos(x +- step, y +- step)`
  - **limFPS**          : To avoid busy-loop, a minimum FramePerSecond value instored

#### H.2.a | Objectifs:
Improve H.1 program replacing the `int draw_needed` flag-based optimization with a **maximal Frames Per Second (FPS)** limit.

The idea is to keep the fun. called by `mlx_hook_loop()` busy _(running continuously)_ , even when the player is static, but to **avoid redrawing the image until a fixed time delay has elapsed**  _(computed from the target FPS)_

This ensures that no more than `FPS` frames per second are displayed, effectively limiting resource consumption while preserving responsiveness.

#### H.2.b | Implementations overview:
To achieve this, we use the `gettimeofday()` fun. to retrieve the current time.

With a few **time-related utility fun.**, we can redraw the image **only when enough time has passed since the previous frame**.

##### H.2.c.i | Add time utils fun `diff_time_in_ms(t1, t2)`
This function returns the time difference between two `struct timeval` values expressed in milliseconds:
```c
int	diff_time_in_ms(struct timeval start, struct timeval end)
{
	int	sec_diff;
	int	usec_diff;

	sec_diff = end.tv_sec - start.tv_sec;
	usec_diff = end.tv_usec - start.tv_usec;
	return (sec_diff * 1000 + usec_diff / 1000);
}
```

##### H.2.c.ii | Add time utils fun. `convert_fps_to_frams_delay(FPS)`
This function returns the delay _(in milliseconds)_ between two frames in order to achieve the desired FPS.
```c
int	convert_fps_to_frame_delay(int fps)
{
	if (fps <= 0)
		return (0);
	return (1000 / fps);
}
```

##### H.2.c.iii | In header
- ADD: `#define FPS 60`
  - This value can be modified to set the maximum allowed frames per second.
- ADD: to `t_data` struct this two new members:
  ```c
  typedef struct s_data
  {
    ...
  	// set once by init_data() by calling convert_fps_to_frams_delay(FPS)
  	int				delay_between_frames_ms;
  	// Updated each time mlx_put_image_to_window() is called
  	struct timeval	last_frame_time;
  }	t_data;
  ```

##### H.2.c.v | In `draw_buffer_image()` called by `mlx_loop_hook()`
```c
int	draw_buffer_image(t_data *dt)
{
  ...
	struct timeval	act_time;
  // STEP 1: Redraw dt->img_buffer
  ...
  // STEP 2: Get current time
	if (gettimeofday(&act_time, NULL) < 0)
		return (perror("draw_buffer_image: gettimeofday() failed"), free_data(dt), 1);
  // If this is the first frame --> SKIP THE WAITING LOOP...
	if (dt->img_drawn) // if not the first frame, enforce the FPS delay == WAIT LOOP!
	{
    // if redrawing step took less time than the FPS corresponding delay....WAIT LOOP...
		while (diff_time_in_ms(dt->last_frame_time, act_time) < dt->delay_between_frames_ms)
		{
			if (gettimeofday(&act_time, NULL) < 0)
				return (perror("draw_buffer_image: gettimeofday() failed"), free_data(dt), 1);
		}
	}
  // STEP 3: Display the image (minimum delay has elapsed)
	mlx_put_image_to_window(dt->mlx_ptr, dt->win_ptr, dt->img_buffer.img_ptr, 0, 0);
	dt->img_drawn++;
  // UPDATE dt->last_frame_time at the right value for next loop!
	if (gettimeofday(&dt->last_frame_time, NULL) < 0)
		return (perror("draw_buffer_image: gettimeofday() failed"), free_data(dt), 1);
```

#### H.2.c | Commands:
- From pwd = `./mlx_lab/`:
  - Compile and Run Program with Valgrind
    ```c
    make -C ./src/h2 v
    ```
  - Clean
    ```c
    make -C src/h2 fc
    ```

#### H.2.d | Observations:
- FPS=30
  - Exec for  2secondes -->   0 steps -->  60 images drawn -->    600allocs
  - Exec for  2secondes -->  40 steps -->  60 images drawn -->    750allocs
  - Exec for  4secondes -->   0 steps --> 120 images drawn -->    900allocs
  - Exec for  4secondes -->  80 steps --> 120 images drawn -->   1200allocs
  - Exec for 10secondes -->   0 steps --> 300 images drawn -->   1900allocs
  - Exec for 10secondes --> 250 steps --> 300 images drawn -->   2900allocs
- FPS=60
  - Exec for  2secondes -->   0 steps --> 120 images drawn -->   1000allocs
  - Exec for  2secondes -->  40 steps --> 120 images drawn -->   1150allocs
  - Exec for  4secondes -->   0 steps --> 240 images drawn -->   1450allocs
  - Exec for  4secondes -->  80 steps --> 240 images drawn -->   1800allocs
  - Exec for 10secondes -->   0 steps --> 600 images drawn -->   3300allocs
  - Exec for 10secondes --> 250 steps --> 600 images drawn -->   4300allocs
- FPS=90
  - Exec for  2secondes -->   0 steps --> 175 images drawn -->   1100allocs
  - Exec for  2secondes -->  50 steps --> 180 images drawn -->   1400allocs
  - Exec for  4secondes -->   0 steps --> 360 images drawn -->   2000allocs
  - Exec for  4secondes -->  90 steps --> 350 images drawn -->   2400allocs
  - Exec for 10secondes -->   0 steps --> 900 images drawn -->   4700allocs
  - Exec for 10secondes --> 275 steps --> 900 images drawn -->   5700allocs

#### H.2.e | Conclusions:
- The frame rate cap _(i.e **FPS limiter**)_  works as intended:
  - Memory allocations remain low and scale mainly with runtime, not with player movement.
  - Higher FPS values increase allocations as expected, but overall usage remains reasonable.
  - The number of rendered images closely matches `FPS x execution_time`, regardless of player movement.
  - The cost of player movement is small compared to the baseline cost of the main `mlx_loop()`

### H.3 | Search for a better memory manipulations (try diff. memcpy...() functions)

- Program's name        : **gridMaze_bresenhamGhost_gridBaseMov_limFPS_diffMemcpy**
  - **gridMaze**        : The first layer, our maze, is represented by a grid.
  - **bresenhameGhost** : The second layer, our player, is represented by a bresenhame circle.
  - **gridBaseMove**    : The player moves **Discretly** : `new_pos(x, y) = old_pos(x +- step, y +- step)`
  - **limFPS**          : To avoid busy-loop, a minimum FramePerSecond value instored
  - **diffMemcpy**      : Implement multiple `memcpy...()` fun. to find the best one...

Until now, we have used images in XPM file format to represent the grids of our maze.

This has allowed us to use the `mlx_xpm_file_to_img()` fun. and easily convert from an integer array to an elegant image representation:

- We had a static image that was copied every frame into a buffer image before adding dynamic layers (player, etc)

- This copy operation (use to calls `mlx_xpm_cpy_src_in_dst()`) iterates pixel-by-pixel across the entire image buffer, which becomes a performance bottleneck at ~20 FPS for larger grids...

>[!TIP]
> Our goal in this project is to **entirely draw** the buffer image by decomposing it **layer-by-layer**:

#### H.3.a | Objectifs:

With this program, we will study and compare different memory-copy strategies to identify the most efficient approach for duplicating image buffers:

1. **Benchmark different memory-copy implementations** to find the fastest approach for duplicating `t_img` buffers.
2. **Eliminate XPM dependency** by building the grid layer programmatically using simple colored rectangles (`img_floor` and `img_wall`).
3. **Measure real-world performance** using `gettimeofday()` to track frame times and achieved FPS.
4. **Provide a command-line interface** to easily switch between different copy strategies for comparison.

>[!WARNING]
> Our Target is: 60 FPS with minimal frame drops. _(this is a really simple program with no big calculation)_

#### H.3.b | Implementations overview:
- Four duplicate methods implemented in `t_img_duplicate.c`:
  - `dup_t_img_by_bits()`: Byte-by-byte copy using a manual while loop.
  - `dup_t_img_by_bytes()`: Copy in 4-byte (int) chunks with remainder handling.
  - `dup_t_img_by_words()`: Copy in 8-byte (size_t) chunks with remainder handling.
  - `dup_t_img_memcpy()`: Standard library `memcpy()` (baseline comparison).

**Architecture Changes**:
1. **Removed XPM dependency**:
   - Replaced `mlx_xpm_file_to_image()` with programmatically-built tile images.
   - `build_img_floor()`: Fills a `TILE_X × TILE_Y` image with `FLOOR_COLOR`.
   - `build_img_wall()`: Fills a `TILE_X × TILE_Y` image with `WALL_COLOR`.
   - `build_img_grid()`: Assembles the full grid by copying floor/wall tiles based on the maze array.

2. **Global variable for runtime configuration**:
   - Declared `extern int dup_method;` in `header.h` (defined in `main.c`).
   - Parsed from command-line args: `0=bits`, `1=bytes`, `2=words`, `3=memcpy`.
   - Used in `draw_buffer_image()` via `switch_duplicate_method()` to select the copy function.

3. **Memory-copy implementations** (`memcpy_utils.c`):
   - `ft_memcpy()`: Basic byte-by-byte loop (baseline).
   - `ft_memcpy_by_bytes()`: Copies in `int` (4-byte) chunks, then remainder.
   - `ft_memcpy_by_words()`: Copies in `size_t` (8-byte) chunks, then remainder.
   - Each function validates pointers and handles alignment edge cases.

4. **Performance measurement**:
   - Frame timing: `gettimeofday()` before and after `dup_t_img()` calls.
   - FPS calculation: `(total_frames / elapsed_time)`.
   - Results printed at program exit with frame count and average FPS.

#### H.3.c | Commands:
- From pwd = `./mlx_lab/`:
  - **Test duplicate functions**:
    - Run using unit memory: **bit** _(works with arg={"0","bit","bits"})_
      ```c
      make -C ./src/h3 valgrind 0
      ```
    - Run using unit memory: **byte**_(works with arg={"1","byte","bytes"})_
      ```c
      make -C ./src/h3 valgrind 1
      ```
    - Run using unit memory: **words**_(works with arg={"2","word","words"})_
      ```c
      make -C ./src/h3 valgrind 2
      ```
    - Run using real `memcpy()` _(works with arg={"3","fast","memcpy"})_
      ```c
      make -C ./src/h3 valgrind 3
      ```

#### H.3.d | Observations:
- **Test duplicate functions**:
  - MEM_BLOCK=0 --> **bits**
    - Exec for 10secondes -->   0 steps --> 200 images drawn -->   1500allocs --> **~65ms** --> **~20FPS** 
    - Exec for 10secondes --> 300 steps --> 200 images drawn -->   2500allocs --> **~65ms** --> **~20FPS**
  - MEM_BLOCK=1 --> **bytes**
    - Exec for 10secondes -->   0 steps --> 600 images drawn -->   3500allocs --> **~25ms** --> **~60FPS** 
    - Exec for 10secondes --> 300 steps --> 600 images drawn -->   4500allocs --> **~25ms** --> **~60FPS**
  - MEM_BLOCK=2 --> **words**
    - Exec for 10secondes -->   0 steps --> 600 images drawn -->   3500allocs --> **~20ms** --> **~60FPS** 
    - Exec for 10secondes --> 300 steps --> 600 images drawn -->   4500allocs --> **~20ms** --> **~60FPS**
  - MEM_BLOCK=3 --> **memcpy()**
    - Exec for 10secondes -->   0 steps --> 600 images drawn -->   3500allocs --> **~10ms** --> **~60FPS** 
    - Exec for 10secondes --> 300 steps --> 600 images drawn -->   4500allocs --> **~10ms** --> **~60FPS**

#### H.3.e | Conclusions:

**Performance Impact Analysis**:
0. **Memory allocation remains stable**:
   - Alloc count scales primarily with runtime and FPS, not with copy method.
   - Player movement adds minimal overhead (~1000 extra allocs per 250 steps over 10s).
   - The FPS limiter effectively prevents runaway allocations.

1. **Copy granularity matters significantly**:
   - **Bit-by-bit** (method 0): ~65ms per frame → **3.25× slower** than target → ~20 FPS (unplayable).
   - **4-byte chunks** (method 1): ~25ms per frame → ~60 FPS (acceptable, 2.5× faster than bits).
   - **8-byte chunks** (method 2): ~20ms per frame → ~60 FPS (good, 3.25× faster than bits).
   - **memcpy()** (method 3): ~10ms per frame → ~60 FPS (best, **6.5× faster** than bits, 2× faster than words).

>[!NOTE]
> memcpy() wins cause comp. opti. using vectorized instructions (SSE/AVX) _(~Vector-Based Access/Mov.)_ where our approch suffer from loop overhead without CPU vectorization _(~Grid-Based Access/Mov.)_ .

### H.4 | Add Vector-Based Movements to the player.

- Program's name        : **GridMaze_BresenHamGhost_VectBaseMove_limFPS_memcpyOpti**
  - **GridMaze**        : The first layer, our maze, is represented by a grid.
  - **BresenHameGhost** : The second layer, our player, is represented by a bresenhame circle.
  - **VectBaseMove**    : The player's movements are now **vector-based**: `pos(x, y) += vect(dir) * int(speed);`
  - **limFPS**          : To avoid busy-loop, a minimum FramePerSecond value instored
  - **memcpyOpti**      : image's manip. used words as memory units _(`size_t`)_
   
- From pwd = `./mlx_lab/`:
  - Run using unit memory: **bit** _(works with arg={"0","bit","bits"})_
    ```c
    make -C ./src/h4 v
    ```